//
//  ListChallengesViewController.swift
//  YourTakeClean
//
//  Created by John Buonassisi on 2017-03-28.
//  Copyright (c) 2017 JAB. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol ListChallengesViewControllerInput {
    func displayFetchedChallenges(viewModel: ListChallenges.FetchChallenges.ViewModel)
}

protocol ListChallengesViewControllerOutput {
    func fetchChallenges(request: ListChallenges.FetchChallenges.Request)
}

class ListChallengesViewController: ReachabilityViewController,
    UITableViewDelegate,
    UITabBarDelegate,
    ListChallengesViewControllerInput {
    // MARK: - Object lifecycle
    
    var output: ListChallengesViewControllerOutput!
    var router: ListChallengesRouter!
    
    var userChallengesDataSource = ListChallengesForUserTableViewDataSource()
    var friendChallengesDataSource = ListChallengesForFriendsTableViewDataSource()
    var noChallengesDataSource = ListChallengesNoChallengesTableViewDataSource()
    var noFriendsDataSource = ListChallengesNoFriendsTableViewDataSource()
    
    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var tabBar: UITabBar!
    @IBOutlet weak var userTab: UITabBarItem!
    @IBOutlet weak var friendsTab: UITabBarItem!
    @IBOutlet weak var addFriendsBarButton: UIBarButtonItem!
    @IBOutlet weak var createChallengeBarButton: UIBarButtonItem!
    @IBOutlet weak var settingsBarButton: UIBarButtonItem!
    
    override func awakeFromNib() {
        super.awakeFromNib()
        ListChallengesConfigurator.sharedInstance.configure(viewController: self)
    }
    
    // MARK: - View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        userChallengesDataSource.viewController = self
        friendChallengesDataSource.viewController = self
        noChallengesDataSource.viewController = self
        noFriendsDataSource.viewController = self
        
        tableView.dataSource = userChallengesDataSource
        tableView.delegate = self
        tableView.rowHeight = UIScreen.main.bounds.size.height
        tableView.allowsSelection = false
        
        let ctNib = UINib(nibName: "ChallengeTableViewCell", bundle: nil)
        tableView.register(ctNib, forCellReuseIdentifier: ListChallengeSceneCellIdentifiers.userChallengeCellId)
        tableView.register(ctNib, forCellReuseIdentifier: ListChallengeSceneCellIdentifiers.friendChallengeCellId)
        
        let ectNib = UINib(nibName: "EmptyChallengeTableViewCell", bundle: nil)
        tableView.register(ectNib, forCellReuseIdentifier: ListChallengeSceneCellIdentifiers.noChallengeCellId)
        
        let nftNib = UINib(nibName: "NoFriendsCell", bundle: nil)
        tableView.register(nftNib, forCellReuseIdentifier: ListChallengeSceneCellIdentifiers.noFriendsCellId)
        
        tableView.refreshControl = UIRefreshControl()
        tableView.refreshControl!.attributedTitle = NSAttributedString(string: "")
        tableView.refreshControl!.addTarget(self, action: #selector(refresh), for: UIControlEvents.valueChanged)
        tableView.refreshControl!.beginRefreshing()
        
        tableView.rowHeight = ChallengeTableViewCell.getHeightofCell(for: UIScreen.main.bounds.size.width)
        
        tabBar.delegate = self
        tabBar.selectedItem = tabBar.items?[0]
        
        fetchChallengesOnLoad()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        navigationController?.navigationBar.isHidden = false
    }
    
    // TODO - Use this method to trigger actions when the network is not available
    override func reachabilityChanged(note: Notification) {
        let reachability = note.object as! Reachability
        
        switch reachability.connection {
        case .wifi:
            print("Reachable via WiFi in List Challenges Scene")
        case .cellular:
            print("Reachable via Cellular in List Challenges Scene")
        case .none:
            print("Network not reachable in List Challenges Scene")
        }
    }
    
    // MARK: - Event handling
    
    func fetchChallengesOnLoad() {
        // NOTE: Ask the Interactor to do some work
        let tag = tabBar.selectedItem!.tag
        let challengeType = ListChallenges.ChallengeRequestType(rawValue: tag)
        let request = ListChallenges.FetchChallenges.Request(challengeType: challengeType!,
                                                             isChallengeAndImageLoadSeparated: false)
        output.fetchChallenges(request: request)
    }
    
    // MARK: - Display logic
    
    func displayFetchedChallenges(viewModel: ListChallenges.FetchChallenges.ViewModel) {
        // NOTE: Display the result from the Presenter
        switch(viewModel.challengeType) {
        case .userChallenges:
            userChallengesDataSource.displayedChallenges = viewModel.displayedChallenges
            tableView.dataSource = userChallengesDataSource
        case .friendChallenges:
            friendChallengesDataSource.displayedChallenges = viewModel.displayedChallenges
            tableView.dataSource = friendChallengesDataSource
        case .noChallenges:
            tableView.dataSource = noChallengesDataSource
        case .noFriends:
            tableView.dataSource = noFriendsDataSource
        }
        
        createChallengeBarButton.isEnabled = viewModel.isChallengeCreationEnabled
        tableView.reloadData()
        tableView.refreshControl!.endRefreshing()
    }
    
    // MARK - Tab Bar Control delegate methods
    
    func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
        fetchChallengesOnLoad()
    }
    
    // MARK - Action methods
    
    func userChallengeCellDrawButtonPressed(sender: UIBarButtonItem!) {
        let challengeId = userChallengesDataSource.displayedChallenges[sender.tag].id
        let challengeImage = userChallengesDataSource.displayedChallenges[sender.tag].challengeImage
        router.navigateToCreateTakeScene(challengeId: challengeId, challengeImage: challengeImage!)
    }
    
    func friendChallengeCellDrawButtonPressed(sender: UIBarButtonItem!) {
        let challengeId = friendChallengesDataSource.displayedChallenges[sender.tag].id
        let challengeImage = friendChallengesDataSource.displayedChallenges[sender.tag].challengeImage
        router.navigateToCreateTakeScene(challengeId: challengeId, challengeImage: challengeImage!)
    }
    
    func userChallengeCellVoteButtonPressed(sender: UIBarButtonItem!) {
        let challengeId = userChallengesDataSource.displayedChallenges[sender.tag].id
        router.navigateToTakesScene(with: challengeId)
    }
    
    func friendChallengeCellVoteButtonPressed(sender: UIBarButtonItem!) {
        let challengeId = friendChallengesDataSource.displayedChallenges[sender.tag].id
        router.navigateToTakesScene(with: challengeId)
    }
    
    @IBAction func createChallenge(_ sender: Any) {
        router.navigateToSnapChallengeImageScene()
    }
    
    @IBAction func viewFriendsManagement(_ sender: Any) {
        router.navigateToFriendManagementScene()
    }
    
    func refresh(sender: UIButton!) {
        let tag = tabBar.selectedItem!.tag
        let challengeType = ListChallenges.ChallengeRequestType(rawValue: tag)
        let request = ListChallenges.FetchChallenges.Request(challengeType: challengeType!,
                                                             isChallengeAndImageLoadSeparated: true)
        output.fetchChallenges(request: request)
    }
}
