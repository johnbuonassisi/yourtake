//
//  ListChallengesInteractor.swift
//  YourTakeClean
//
//  Created by John Buonassisi on 2017-03-28.
//  Copyright (c) 2017 JAB. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol ListChallengesInteractorInput
{
  func fetchChallenges(request: ListChallenges.FetchChallenges.Request)
  var userChallenges: [ChallengeDto]? { get }
  var friendChallenges: [ChallengeDto]? { get }
}

protocol ListChallengesInteractorOutput
{
  func presentFetchedChallenges(response: ListChallenges.FetchChallenges.Response)
}

class ListChallengesInteractor: ListChallengesInteractorInput
{
  var output: ListChallengesInteractorOutput!
  var challengesWorker = ChallengesWorker(challengesStore: ChallengesBaasBoxStore())
  
  var userChallenges: [ChallengeDto]?
  var friendChallenges: [ChallengeDto]?
  
  // MARK: - Business logic
  
  // Determine which type of challenges should be fetched from the store (user or friend)
  // Fetch the challenges from the store asynchronously
    // Once the challenges are retrieved, create a response and send to the Presenter
    // For each retrieved challenge
      // Download the associated image asynchronously
        // Update the challenge in the response with the downloaded image
        // Send the response to the Presenter
  
  func fetchChallenges(request: ListChallenges.FetchChallenges.Request)
  {
    let challengeType =
      ListChallenges.FetchChallenges.Response.ChallengeResponseType(rawValue: request.challengeType.rawValue)
    
    switch(request.challengeType) {
    case .userChallenges:
      
      challengesWorker.fetchChallenges(completionHandler: { (challenges) -> Void in
        
        self.userChallenges = challenges
        self.fetchChallengesAndSendResponseToPresenter(challenges: self.userChallenges, challengeType: challengeType!)
        
      })
    case .friendChallenges:
      challengesWorker.fetchFriendChallenges(completionHandler: { (challenges) -> Void in
        self.friendChallenges = challenges
        self.fetchChallengesAndSendResponseToPresenter(challenges: self.friendChallenges, challengeType: challengeType!)
      })
    }
  }

  func fetchChallengesAndSendResponseToPresenter(challenges: [ChallengeDto]?,
                                             challengeType: ListChallenges.FetchChallenges.Response.ChallengeResponseType) {
    
    if let challenges = challenges {
      let response = ListChallenges.FetchChallenges.Response(challengeType: challengeType,
                                                             challenges: challenges)
      self.output.presentFetchedChallenges(response: response)
      
      for challenge in challenges {
        challengesWorker.downloadImage(with: challenge.imageId, completion: { (image) -> Void in
          challenge.image = image
          let response = ListChallenges.FetchChallenges.Response(challengeType: challengeType,
                                                                 challenges: challenges)
          self.output.presentFetchedChallenges(response: response)
        })
      }
    } else {
      print("Error: Challenge List is nil")
    }
  }
}
