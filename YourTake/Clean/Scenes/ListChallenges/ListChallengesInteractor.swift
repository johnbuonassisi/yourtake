//
//  ListChallengesInteractor.swift
//  YourTakeClean
//
//  Created by John Buonassisi on 2017-03-28.
//  Copyright (c) 2017 JAB. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol ListChallengesInteractorInput
{
  func fetchChallenges(request: ListChallenges.FetchChallenges.Request)
}

protocol ListChallengesInteractorOutput
{
  func presentFetchedChallenges(response: ListChallenges.FetchChallenges.Response)
}

class ListChallengesInteractor: ListChallengesInteractorInput
{
  var output: ListChallengesInteractorOutput!
  var challengesWorker = ChallengesWorker(challengesStore: ChallengesBaasBoxStore())
  
  var userChallenges: [ChallengeDto]?
  var friendChallenges: [ChallengeDto]?
  
  // MARK: - Business logic
  
  // fetchChallenges
  //
  // Determine which type of challenges should be fetched from the store (user or friend)
  // Fetch the challenges from the store asynchronously
    // Once the challenges are retrieved, create a response and send to the Presenter
    // For each retrieved challenge
      // Download the associated image asynchronously
        // Update the challenge in the response with the downloaded image
        // Send the response to the Presenter
  
  func fetchChallenges(request: ListChallenges.FetchChallenges.Request)
  {
    let challengeType =
      ListChallenges.FetchChallenges.Response.ChallengeResponseType(rawValue: request.challengeType.rawValue)
    
    switch(request.challengeType) {
    case .userChallenges:
      
      challengesWorker.fetchChallenges(completionHandler: { (challenges) -> Void in
        
        self.userChallenges = challenges
        self.fetchChallengeImagesAndSendResponseToPresenter(challenges: self.userChallenges,
                                                       challengeType: challengeType!,
                                                       isChallengeAndImageLoadSeparated: true)
        
      })
    case .friendChallenges:
      challengesWorker.fetchFriendChallenges(completionHandler: { (challenges) -> Void in
        self.friendChallenges = challenges
        self.fetchChallengeImagesAndSendResponseToPresenter(challenges: self.friendChallenges,
                                                       challengeType: challengeType!,
                                                       isChallengeAndImageLoadSeparated: true)
      })
    }
  }

  // fetchChallengeImagesAndSendResponseToPresenter
  //
  // Will get the challenge images for each challenge in the passed in list. The 
  // isChallengeAndImageSeparted flag can be used to delay presentation of the challenges
  // until all images have been fetched.
  private func fetchChallengeImagesAndSendResponseToPresenter(challenges: [ChallengeDto]?,
                                             challengeType: ListChallenges.FetchChallenges.Response.ChallengeResponseType,
                                             isChallengeAndImageLoadSeparated: Bool) {
    
    if let challenges = challenges {
      let response = ListChallenges.FetchChallenges.Response(challengeType: challengeType,
                                                             challenges: challenges)
      
      if(challenges.count == 0) {
        // When there are no challenges, present something immediately
        output.presentFetchedChallenges(response: response)
        return
      }
      
      if !isChallengeAndImageLoadSeparated {
        // There are some situations where we want to wait for all challenge images
        // to be downloaded before presenting the challenges to the user
        self.output.presentFetchedChallenges(response: response)
      }
      
      for challenge in challenges {
        challengesWorker.downloadImage(with: challenge.imageId, completion: { (image) -> Void in
          challenge.image = image
          let response = ListChallenges.FetchChallenges.Response(challengeType: challengeType,
                                                                 challenges: challenges)
          self.output.presentFetchedChallenges(response: response)
        })
      }
    } else {
      print("Error: Challenge List is nil")
    }
  }
}
