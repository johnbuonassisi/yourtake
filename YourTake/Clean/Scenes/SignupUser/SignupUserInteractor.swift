//
//  SignupUserInteractor.swift
//  YourTake
//
//  Created by John Buonassisi on 2017-04-15.
//  Copyright (c) 2017 Enovi Inc. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol SignupUserInteractorInput
{
  func signup(request: SignupUser.Signup.Request, completion: ((Bool) -> Void)?)
}

protocol SignupUserInteractorOutput
{
  func presentSignup(response: SignupUser.Signup.Response)
}

class SignupUserInteractor: SignupUserInteractorInput
{
  var output: SignupUserInteractorOutput!
  var worker = SignupWorker(signupStore: SignupBaasBoxStore())
  
  private var isValidEmailAddress = false
  private var isValidUsername = false
  private var isValidPassword = false
  
  // MARK: - Business logic
  
  func signup(request: SignupUser.Signup.Request, completion: ((Bool) -> Void)?)
  {

    switch request.requestType {
    case .signupRequest:
      if ValidationService.isValidEmailAddress(request.emailAddress) == false ||
        ValidationService.isValidUserName(request.username) == false ||
        ValidationService.isValidPassword(request.password) == false {
        print("Signup form not properly filled by user")
        print("email: \(request.emailAddress), username: \(request.username), password: \(request.password)")
        return
      }
      worker.signup(emailAddress: request.emailAddress,
                   username: request.username,
                   password: request.password,
                   completion: { (isSignupSuccess) -> Void in
                    if(isSignupSuccess) {
                      
                      // Save the username and password to the keychain
                      let passwordItem = KeychainPasswordItem(service: KeychainConfiguration.serviceName,
                                                              account: request.username,
                                                              accessGroup: KeychainConfiguration.accessGroup)
                      do {
                        try passwordItem.savePassword(request.password)
                      } catch {
                        fatalError("Error updating keychain - \(error)")
                      }
                      completion!(true)
                    } else {
                      completion!(false)
                    }
      })
      return
    case .emailAddressVerification:
      isValidEmailAddress = ValidationService.isValidEmailAddress(request.emailAddress)
    case .userNameVerification:
      isValidUsername = ValidationService.isValidUserName(request.username)
    case .passwordVerification:
      isValidPassword = ValidationService.isValidPassword(request.password)
    }
    
    let response = SignupUser.Signup.Response(isEmailValid: isValidEmailAddress,
                                              isUserNameValid: isValidUsername,
                                              isPasswordValid: isValidPassword)
    output.presentSignup(response: response)
  }
  
}
